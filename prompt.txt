filterchain:
@Slf4j
@Configuration
@RequiredArgsConstructor
public class WebSecurityConfiguration {
  private final AuthorizationAuthenticationHandler handler;
  private final CustomOauth2UserService customOAuth2UserService;
  private final ManageToken manageToken;
  private static final String LOGIN_PROCESSING_URL = "http://localhost:5173/login";

  @Bean
  protected SecurityFilterChain filterChain(
      HttpSecurity http, KeycloakAuthenticationConverter authenticationConverter
  ) throws Exception {
    log.info("Configuring security filter chain");
    return http
        .addFilterBefore(manageToken, UsernamePasswordAuthenticationFilter.class)
        .cors(Customizer.withDefaults())
        .csrf(AbstractHttpConfigurer::disable)
        .oauth2ResourceServer(oauth2 ->
            oauth2.jwt(jwt -> jwt.jwtAuthenticationConverter(authenticationConverter))
        ).authorizeHttpRequests(requests -> requests
            .requestMatchers(new AntPathRequestMatcher(String.format("/%s/v*/**", API))).authenticated()
            .anyRequest().permitAll()
        ).formLogin(
            form -> form
                .loginPage(LOGIN_PROCESSING_URL)
                .loginProcessingUrl(LOGIN_PROCESSING_URL)
                .defaultSuccessUrl(String.format("/%s/%s/swagger-ui/index.html", API, API_VERSION), true)
                .failureUrl(LOGIN_PROCESSING_URL + "?error=true")
                .permitAll()
        ).oauth2Login(oauth -> oauth
            .loginPage(LOGIN_PROCESSING_URL)
            .userInfoEndpoint(userInfo -> userInfo
                .oidcUserService(customOAuth2UserService)
            ).defaultSuccessUrl(String.format("/%s/%s/swagger-ui/index.html", API, API_VERSION), true)
            .permitAll()
        ).logout(logout -> logout
            .logoutSuccessUrl("/")
            .invalidateHttpSession(true)
            .deleteCookies("JSESSIONID")
        ).sessionManagement(session -> {
              session.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);
              session.maximumSessions(1).maxSessionsPreventsLogin(false);
            }
        ).exceptionHandling(exceptionHandling -> exceptionHandling
            .authenticationEntryPoint((_, res, _) ->
                res.sendRedirect(LOGIN_PROCESSING_URL)
            ).defaultAuthenticationEntryPointFor(handler, new AntPathRequestMatcher(String.format("/%s/**", API)))
            .defaultAccessDeniedHandlerFor(handler, new AntPathRequestMatcher((String.format("/%s/**", API))))
        ).build();
  }

  @Component
  @RequiredArgsConstructor
  protected static class KeycloakAuthenticationConverter
      implements Converter<Jwt, JwtAuthenticationToken> {
    private final KeycloakAuthoritiesConverter authoritiesConverter;

    @Override
    public JwtAuthenticationToken convert(@NonNull Jwt jwt) {
      return new JwtAuthenticationToken(jwt, authoritiesConverter.convert(jwt),
          List.of(jwt.getClaimAsString(StandardClaimNames.SUB)).toString()
      );
    }

    @Component
    static class KeycloakAuthoritiesConverter
        implements Converter<Jwt, List<SimpleGrantedAuthority>> {
      @Value("${keycloak.client-id}")
      private String clientId;
      @Override
      @SuppressWarnings({"unchecked"})
      public List<SimpleGrantedAuthority> convert(@NonNull Jwt jwt) {
        final var realmAccess = (Map<String, Object>) jwt.getClaims()
            .getOrDefault("resource_access", Map.of());
        final var client = (Map<String, Object>) realmAccess.getOrDefault(clientId, Map.of());
        final var roles = (List<String>) client
            .getOrDefault("roles", List.of());
        final List<String> prefixRoles = roles.stream().map(s -> "ROLE_" + s).toList();
        final String clientScope = (String) jwt.getClaims()
            .getOrDefault("scope", "");
        final List<String> prefixScope = Arrays.stream(clientScope.split(" "))
            .map(s -> "SCOPE_" + s).toList();
        List<String> authorities = new ArrayList<>();
        authorities.addAll(prefixRoles);
        authorities.addAll(prefixScope);
        return authorities.stream().map(SimpleGrantedAuthority::new).toList();
      }
    }
  }

}
app.tsx:
function App() {
    const Watermark = () => (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            background: 'url(/corno_hamal.svg) center center no-repeat',
            backgroundSize: 'contain',
            opacity: 0.2,
            pointerEvents: 'none',
            zIndex: 9999,
        }} />
    );
    const redirectUri = "http://localhost:8082/ala/v1/swagger-ui/index.html";
    return (
        <div style={{ maxWidth: 400, margin: "auto", padding: 20, fontFamily: "sans-serif" }}>
            <Watermark />
            <h2>Benvenuto!</h2>
            <hr />
            <h3>Oppure</h3>

            <div className="flex flex-col items-center gap-4 mt-10">
                <a
                    href={`${import.meta.env.VITE_KC_LOGIN_URL}?redirect_uri=${encodeURIComponent(redirectUri)}`}
                    className="btn btn-keycloak"
                >
                    Accedi con Keycloak
                </a>
            </div>
        </div>
    );
}
export default App;
properties:
# Keycloak
keycloak.host=${SCHEMA:http}://${HOST:keycloak}:${KC_EXTERNAL_PORT:5443}
keycloak.realm.name=${KC_REALM_NAME:user-auth}
keycloak.client.name=client-be
keycloak.client-id=${keycloak.realm.name}-${keycloak.client.name}
keycloak.authorization-grant-type=password
keycloak.host.realm=${keycloak.host}/realms/${keycloak.realm.name}
keycloak.host.user=${keycloak.host}/admin/realms/${keycloak.realm.name}/users
spring.security.oauth2.resourceserver.jwt.issuer-uri=${keycloak.host.realm}
spring.security.oauth2.client.registration.keycloak.client-id=${keycloak.client-id}
spring.security.oauth2.client.registration.keycloak.authorization-grant-type=${keycloak.authorization-grant-type}
spring.security.oauth2.client.registration.keycloak.client-name=${keycloak.client-id}
spring.security.oauth2.client.registration.keycloak.client-authentication-method=POST
spring.security.oauth2.client.registration.keycloak.provider=keycloak
spring.security.oauth2.client.provider.keycloak.issuer-uri=${keycloak.host.realm}

## Google
spring.security.oauth2.client.registration.google.redirect-uri=${GOOGLE_REDIRECT_URI}
spring.security.oauth2.client.registration.google.client-id=${GOOGLE_CLIENT_ID}
spring.security.oauth2.client.registration.google.client-secret=${GOOGLE_CLIENT_SECRET}
spring.security.oauth2.client.registration.google.scope=openid, profile, email
#google.link=${baseUrl}/authorization/google
google.link=${BASE_URL}:${BE_PORT}/oauth2/authorization/google
Quando accedo dal fe faccio login correttamente e mi manda su http://localhost:5173/login ma voglio andare su swagger. Come faccio?